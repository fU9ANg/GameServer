// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PROTOCOL.proto

#ifndef PROTOBUF_PROTOCOL_2eproto__INCLUDED
#define PROTOBUF_PROTOCOL_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Netty4 {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PROTOCOL_2eproto();
void protobuf_AssignDesc_PROTOCOL_2eproto();
void protobuf_ShutdownFile_PROTOCOL_2eproto();

class ProtocolMessage;
class CommRlt;
class ReqLogin;
class RespLogin;
class PPTNode;
class ReqPPTList;
class RespPPTList;

enum CommMessageType {
  CMT_C_LOGIN = 100,
  CMT_C_PPTLIST = 101,
  CMT_S_LOGIN = 1000,
  CMT_S_PPTLIST = 1001
};
bool CommMessageType_IsValid(int value);
const CommMessageType CommMessageType_MIN = CMT_C_LOGIN;
const CommMessageType CommMessageType_MAX = CMT_S_PPTLIST;
const int CommMessageType_ARRAYSIZE = CommMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommMessageType_descriptor();
inline const ::std::string& CommMessageType_Name(CommMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommMessageType_descriptor(), value);
}
inline bool CommMessageType_Parse(
    const ::std::string& name, CommMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommMessageType>(
    CommMessageType_descriptor(), name, value);
}
// ===================================================================

class ProtocolMessage : public ::google::protobuf::Message {
 public:
  ProtocolMessage();
  virtual ~ProtocolMessage();

  ProtocolMessage(const ProtocolMessage& from);

  inline ProtocolMessage& operator=(const ProtocolMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtocolMessage& default_instance();

  void Swap(ProtocolMessage* other);

  // implements Message ----------------------------------------------

  ProtocolMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtocolMessage& from);
  void MergeFrom(const ProtocolMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Netty4.CommMessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Netty4::CommMessageType type() const;
  inline void set_type(::Netty4::CommMessageType value);

  // optional .Netty4.ReqLogin req_login = 2;
  inline bool has_req_login() const;
  inline void clear_req_login();
  static const int kReqLoginFieldNumber = 2;
  inline const ::Netty4::ReqLogin& req_login() const;
  inline ::Netty4::ReqLogin* mutable_req_login();
  inline ::Netty4::ReqLogin* release_req_login();
  inline void set_allocated_req_login(::Netty4::ReqLogin* req_login);

  // optional .Netty4.RespLogin resp_login = 3;
  inline bool has_resp_login() const;
  inline void clear_resp_login();
  static const int kRespLoginFieldNumber = 3;
  inline const ::Netty4::RespLogin& resp_login() const;
  inline ::Netty4::RespLogin* mutable_resp_login();
  inline ::Netty4::RespLogin* release_resp_login();
  inline void set_allocated_resp_login(::Netty4::RespLogin* resp_login);

  // optional .Netty4.ReqPPTList req_ppt_list = 4;
  inline bool has_req_ppt_list() const;
  inline void clear_req_ppt_list();
  static const int kReqPptListFieldNumber = 4;
  inline const ::Netty4::ReqPPTList& req_ppt_list() const;
  inline ::Netty4::ReqPPTList* mutable_req_ppt_list();
  inline ::Netty4::ReqPPTList* release_req_ppt_list();
  inline void set_allocated_req_ppt_list(::Netty4::ReqPPTList* req_ppt_list);

  // optional .Netty4.RespPPTList resp_ppt_list = 5;
  inline bool has_resp_ppt_list() const;
  inline void clear_resp_ppt_list();
  static const int kRespPptListFieldNumber = 5;
  inline const ::Netty4::RespPPTList& resp_ppt_list() const;
  inline ::Netty4::RespPPTList* mutable_resp_ppt_list();
  inline ::Netty4::RespPPTList* release_resp_ppt_list();
  inline void set_allocated_resp_ppt_list(::Netty4::RespPPTList* resp_ppt_list);

  // @@protoc_insertion_point(class_scope:Netty4.ProtocolMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_req_login();
  inline void clear_has_req_login();
  inline void set_has_resp_login();
  inline void clear_has_resp_login();
  inline void set_has_req_ppt_list();
  inline void clear_has_req_ppt_list();
  inline void set_has_resp_ppt_list();
  inline void clear_has_resp_ppt_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Netty4::ReqLogin* req_login_;
  ::Netty4::RespLogin* resp_login_;
  ::Netty4::ReqPPTList* req_ppt_list_;
  ::Netty4::RespPPTList* resp_ppt_list_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PROTOCOL_2eproto();
  friend void protobuf_AssignDesc_PROTOCOL_2eproto();
  friend void protobuf_ShutdownFile_PROTOCOL_2eproto();

  void InitAsDefaultInstance();
  static ProtocolMessage* default_instance_;
};
// -------------------------------------------------------------------

class CommRlt : public ::google::protobuf::Message {
 public:
  CommRlt();
  virtual ~CommRlt();

  CommRlt(const CommRlt& from);

  inline CommRlt& operator=(const CommRlt& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommRlt& default_instance();

  void Swap(CommRlt* other);

  // implements Message ----------------------------------------------

  CommRlt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommRlt& from);
  void MergeFrom(const CommRlt& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:Netty4.CommRlt)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msg_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_PROTOCOL_2eproto();
  friend void protobuf_AssignDesc_PROTOCOL_2eproto();
  friend void protobuf_ShutdownFile_PROTOCOL_2eproto();

  void InitAsDefaultInstance();
  static CommRlt* default_instance_;
};
// -------------------------------------------------------------------

class ReqLogin : public ::google::protobuf::Message {
 public:
  ReqLogin();
  virtual ~ReqLogin();

  ReqLogin(const ReqLogin& from);

  inline ReqLogin& operator=(const ReqLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLogin& default_instance();

  void Swap(ReqLogin* other);

  // implements Message ----------------------------------------------

  ReqLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqLogin& from);
  void MergeFrom(const ReqLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string platform = 3;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 3;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // optional string app_version = 4;
  inline bool has_app_version() const;
  inline void clear_app_version();
  static const int kAppVersionFieldNumber = 4;
  inline const ::std::string& app_version() const;
  inline void set_app_version(const ::std::string& value);
  inline void set_app_version(const char* value);
  inline void set_app_version(const char* value, size_t size);
  inline ::std::string* mutable_app_version();
  inline ::std::string* release_app_version();
  inline void set_allocated_app_version(::std::string* app_version);

  // @@protoc_insertion_point(class_scope:Netty4.ReqLogin)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_app_version();
  inline void clear_has_app_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::std::string* platform_;
  ::std::string* app_version_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_PROTOCOL_2eproto();
  friend void protobuf_AssignDesc_PROTOCOL_2eproto();
  friend void protobuf_ShutdownFile_PROTOCOL_2eproto();

  void InitAsDefaultInstance();
  static ReqLogin* default_instance_;
};
// -------------------------------------------------------------------

class RespLogin : public ::google::protobuf::Message {
 public:
  RespLogin();
  virtual ~RespLogin();

  RespLogin(const RespLogin& from);

  inline RespLogin& operator=(const RespLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespLogin& default_instance();

  void Swap(RespLogin* other);

  // implements Message ----------------------------------------------

  RespLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RespLogin& from);
  void MergeFrom(const RespLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Netty4.CommRlt rlt = 1;
  inline bool has_rlt() const;
  inline void clear_rlt();
  static const int kRltFieldNumber = 1;
  inline const ::Netty4::CommRlt& rlt() const;
  inline ::Netty4::CommRlt* mutable_rlt();
  inline ::Netty4::CommRlt* release_rlt();
  inline void set_allocated_rlt(::Netty4::CommRlt* rlt);

  // @@protoc_insertion_point(class_scope:Netty4.RespLogin)
 private:
  inline void set_has_rlt();
  inline void clear_has_rlt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Netty4::CommRlt* rlt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_PROTOCOL_2eproto();
  friend void protobuf_AssignDesc_PROTOCOL_2eproto();
  friend void protobuf_ShutdownFile_PROTOCOL_2eproto();

  void InitAsDefaultInstance();
  static RespLogin* default_instance_;
};
// -------------------------------------------------------------------

class PPTNode : public ::google::protobuf::Message {
 public:
  PPTNode();
  virtual ~PPTNode();

  PPTNode(const PPTNode& from);

  inline PPTNode& operator=(const PPTNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PPTNode& default_instance();

  void Swap(PPTNode* other);

  // implements Message ----------------------------------------------

  PPTNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PPTNode& from);
  void MergeFrom(const PPTNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string image = 2;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 2;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional int32 order = 3;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 3;
  inline ::google::protobuf::int32 order() const;
  inline void set_order(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Netty4.PPTNode)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_order();
  inline void clear_has_order();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* image_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_PROTOCOL_2eproto();
  friend void protobuf_AssignDesc_PROTOCOL_2eproto();
  friend void protobuf_ShutdownFile_PROTOCOL_2eproto();

  void InitAsDefaultInstance();
  static PPTNode* default_instance_;
};
// -------------------------------------------------------------------

class ReqPPTList : public ::google::protobuf::Message {
 public:
  ReqPPTList();
  virtual ~ReqPPTList();

  ReqPPTList(const ReqPPTList& from);

  inline ReqPPTList& operator=(const ReqPPTList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqPPTList& default_instance();

  void Swap(ReqPPTList* other);

  // implements Message ----------------------------------------------

  ReqPPTList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqPPTList& from);
  void MergeFrom(const ReqPPTList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 vspid = 1;
  inline bool has_vspid() const;
  inline void clear_vspid();
  static const int kVspidFieldNumber = 1;
  inline ::google::protobuf::int32 vspid() const;
  inline void set_vspid(::google::protobuf::int32 value);

  // required int32 userid = 2;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 2;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Netty4.ReqPPTList)
 private:
  inline void set_has_vspid();
  inline void clear_has_vspid();
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 vspid_;
  ::google::protobuf::int32 userid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_PROTOCOL_2eproto();
  friend void protobuf_AssignDesc_PROTOCOL_2eproto();
  friend void protobuf_ShutdownFile_PROTOCOL_2eproto();

  void InitAsDefaultInstance();
  static ReqPPTList* default_instance_;
};
// -------------------------------------------------------------------

class RespPPTList : public ::google::protobuf::Message {
 public:
  RespPPTList();
  virtual ~RespPPTList();

  RespPPTList(const RespPPTList& from);

  inline RespPPTList& operator=(const RespPPTList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespPPTList& default_instance();

  void Swap(RespPPTList* other);

  // implements Message ----------------------------------------------

  RespPPTList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RespPPTList& from);
  void MergeFrom(const RespPPTList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Netty4.CommRlt rlt = 1;
  inline bool has_rlt() const;
  inline void clear_rlt();
  static const int kRltFieldNumber = 1;
  inline const ::Netty4::CommRlt& rlt() const;
  inline ::Netty4::CommRlt* mutable_rlt();
  inline ::Netty4::CommRlt* release_rlt();
  inline void set_allocated_rlt(::Netty4::CommRlt* rlt);

  // required int32 tag = 2;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 2;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // optional string desc = 3;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // repeated .Netty4.PPTNode node = 4;
  inline int node_size() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 4;
  inline const ::Netty4::PPTNode& node(int index) const;
  inline ::Netty4::PPTNode* mutable_node(int index);
  inline ::Netty4::PPTNode* add_node();
  inline const ::google::protobuf::RepeatedPtrField< ::Netty4::PPTNode >&
      node() const;
  inline ::google::protobuf::RepeatedPtrField< ::Netty4::PPTNode >*
      mutable_node();

  // @@protoc_insertion_point(class_scope:Netty4.RespPPTList)
 private:
  inline void set_has_rlt();
  inline void clear_has_rlt();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_desc();
  inline void clear_has_desc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Netty4::CommRlt* rlt_;
  ::std::string* desc_;
  ::google::protobuf::RepeatedPtrField< ::Netty4::PPTNode > node_;
  ::google::protobuf::int32 tag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_PROTOCOL_2eproto();
  friend void protobuf_AssignDesc_PROTOCOL_2eproto();
  friend void protobuf_ShutdownFile_PROTOCOL_2eproto();

  void InitAsDefaultInstance();
  static RespPPTList* default_instance_;
};
// ===================================================================


// ===================================================================

// ProtocolMessage

// required .Netty4.CommMessageType type = 1;
inline bool ProtocolMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtocolMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtocolMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtocolMessage::clear_type() {
  type_ = 100;
  clear_has_type();
}
inline ::Netty4::CommMessageType ProtocolMessage::type() const {
  return static_cast< ::Netty4::CommMessageType >(type_);
}
inline void ProtocolMessage::set_type(::Netty4::CommMessageType value) {
  assert(::Netty4::CommMessageType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Netty4.ReqLogin req_login = 2;
inline bool ProtocolMessage::has_req_login() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtocolMessage::set_has_req_login() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtocolMessage::clear_has_req_login() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtocolMessage::clear_req_login() {
  if (req_login_ != NULL) req_login_->::Netty4::ReqLogin::Clear();
  clear_has_req_login();
}
inline const ::Netty4::ReqLogin& ProtocolMessage::req_login() const {
  return req_login_ != NULL ? *req_login_ : *default_instance_->req_login_;
}
inline ::Netty4::ReqLogin* ProtocolMessage::mutable_req_login() {
  set_has_req_login();
  if (req_login_ == NULL) req_login_ = new ::Netty4::ReqLogin;
  return req_login_;
}
inline ::Netty4::ReqLogin* ProtocolMessage::release_req_login() {
  clear_has_req_login();
  ::Netty4::ReqLogin* temp = req_login_;
  req_login_ = NULL;
  return temp;
}
inline void ProtocolMessage::set_allocated_req_login(::Netty4::ReqLogin* req_login) {
  delete req_login_;
  req_login_ = req_login;
  if (req_login) {
    set_has_req_login();
  } else {
    clear_has_req_login();
  }
}

// optional .Netty4.RespLogin resp_login = 3;
inline bool ProtocolMessage::has_resp_login() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtocolMessage::set_has_resp_login() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtocolMessage::clear_has_resp_login() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtocolMessage::clear_resp_login() {
  if (resp_login_ != NULL) resp_login_->::Netty4::RespLogin::Clear();
  clear_has_resp_login();
}
inline const ::Netty4::RespLogin& ProtocolMessage::resp_login() const {
  return resp_login_ != NULL ? *resp_login_ : *default_instance_->resp_login_;
}
inline ::Netty4::RespLogin* ProtocolMessage::mutable_resp_login() {
  set_has_resp_login();
  if (resp_login_ == NULL) resp_login_ = new ::Netty4::RespLogin;
  return resp_login_;
}
inline ::Netty4::RespLogin* ProtocolMessage::release_resp_login() {
  clear_has_resp_login();
  ::Netty4::RespLogin* temp = resp_login_;
  resp_login_ = NULL;
  return temp;
}
inline void ProtocolMessage::set_allocated_resp_login(::Netty4::RespLogin* resp_login) {
  delete resp_login_;
  resp_login_ = resp_login;
  if (resp_login) {
    set_has_resp_login();
  } else {
    clear_has_resp_login();
  }
}

// optional .Netty4.ReqPPTList req_ppt_list = 4;
inline bool ProtocolMessage::has_req_ppt_list() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtocolMessage::set_has_req_ppt_list() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtocolMessage::clear_has_req_ppt_list() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtocolMessage::clear_req_ppt_list() {
  if (req_ppt_list_ != NULL) req_ppt_list_->::Netty4::ReqPPTList::Clear();
  clear_has_req_ppt_list();
}
inline const ::Netty4::ReqPPTList& ProtocolMessage::req_ppt_list() const {
  return req_ppt_list_ != NULL ? *req_ppt_list_ : *default_instance_->req_ppt_list_;
}
inline ::Netty4::ReqPPTList* ProtocolMessage::mutable_req_ppt_list() {
  set_has_req_ppt_list();
  if (req_ppt_list_ == NULL) req_ppt_list_ = new ::Netty4::ReqPPTList;
  return req_ppt_list_;
}
inline ::Netty4::ReqPPTList* ProtocolMessage::release_req_ppt_list() {
  clear_has_req_ppt_list();
  ::Netty4::ReqPPTList* temp = req_ppt_list_;
  req_ppt_list_ = NULL;
  return temp;
}
inline void ProtocolMessage::set_allocated_req_ppt_list(::Netty4::ReqPPTList* req_ppt_list) {
  delete req_ppt_list_;
  req_ppt_list_ = req_ppt_list;
  if (req_ppt_list) {
    set_has_req_ppt_list();
  } else {
    clear_has_req_ppt_list();
  }
}

// optional .Netty4.RespPPTList resp_ppt_list = 5;
inline bool ProtocolMessage::has_resp_ppt_list() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtocolMessage::set_has_resp_ppt_list() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtocolMessage::clear_has_resp_ppt_list() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtocolMessage::clear_resp_ppt_list() {
  if (resp_ppt_list_ != NULL) resp_ppt_list_->::Netty4::RespPPTList::Clear();
  clear_has_resp_ppt_list();
}
inline const ::Netty4::RespPPTList& ProtocolMessage::resp_ppt_list() const {
  return resp_ppt_list_ != NULL ? *resp_ppt_list_ : *default_instance_->resp_ppt_list_;
}
inline ::Netty4::RespPPTList* ProtocolMessage::mutable_resp_ppt_list() {
  set_has_resp_ppt_list();
  if (resp_ppt_list_ == NULL) resp_ppt_list_ = new ::Netty4::RespPPTList;
  return resp_ppt_list_;
}
inline ::Netty4::RespPPTList* ProtocolMessage::release_resp_ppt_list() {
  clear_has_resp_ppt_list();
  ::Netty4::RespPPTList* temp = resp_ppt_list_;
  resp_ppt_list_ = NULL;
  return temp;
}
inline void ProtocolMessage::set_allocated_resp_ppt_list(::Netty4::RespPPTList* resp_ppt_list) {
  delete resp_ppt_list_;
  resp_ppt_list_ = resp_ppt_list;
  if (resp_ppt_list) {
    set_has_resp_ppt_list();
  } else {
    clear_has_resp_ppt_list();
  }
}

// -------------------------------------------------------------------

// CommRlt

// required int32 code = 1;
inline bool CommRlt::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommRlt::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommRlt::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommRlt::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 CommRlt::code() const {
  return code_;
}
inline void CommRlt::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required string msg = 2;
inline bool CommRlt::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommRlt::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommRlt::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommRlt::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& CommRlt::msg() const {
  return *msg_;
}
inline void CommRlt::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void CommRlt::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void CommRlt::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommRlt::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* CommRlt::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommRlt::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqLogin

// required int32 id = 1;
inline bool ReqLogin::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqLogin::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqLogin::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqLogin::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ReqLogin::id() const {
  return id_;
}
inline void ReqLogin::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string token = 2;
inline bool ReqLogin::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqLogin::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqLogin::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqLogin::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ReqLogin::token() const {
  return *token_;
}
inline void ReqLogin::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ReqLogin::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ReqLogin::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogin::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ReqLogin::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLogin::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string platform = 3;
inline bool ReqLogin::has_platform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqLogin::set_has_platform() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqLogin::clear_has_platform() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqLogin::clear_platform() {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    platform_->clear();
  }
  clear_has_platform();
}
inline const ::std::string& ReqLogin::platform() const {
  return *platform_;
}
inline void ReqLogin::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void ReqLogin::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void ReqLogin::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogin::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  return platform_;
}
inline ::std::string* ReqLogin::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLogin::set_allocated_platform(::std::string* platform) {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string app_version = 4;
inline bool ReqLogin::has_app_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqLogin::set_has_app_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqLogin::clear_has_app_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqLogin::clear_app_version() {
  if (app_version_ != &::google::protobuf::internal::kEmptyString) {
    app_version_->clear();
  }
  clear_has_app_version();
}
inline const ::std::string& ReqLogin::app_version() const {
  return *app_version_;
}
inline void ReqLogin::set_app_version(const ::std::string& value) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::kEmptyString) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(value);
}
inline void ReqLogin::set_app_version(const char* value) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::kEmptyString) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(value);
}
inline void ReqLogin::set_app_version(const char* value, size_t size) {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::kEmptyString) {
    app_version_ = new ::std::string;
  }
  app_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogin::mutable_app_version() {
  set_has_app_version();
  if (app_version_ == &::google::protobuf::internal::kEmptyString) {
    app_version_ = new ::std::string;
  }
  return app_version_;
}
inline ::std::string* ReqLogin::release_app_version() {
  clear_has_app_version();
  if (app_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = app_version_;
    app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLogin::set_allocated_app_version(::std::string* app_version) {
  if (app_version_ != &::google::protobuf::internal::kEmptyString) {
    delete app_version_;
  }
  if (app_version) {
    set_has_app_version();
    app_version_ = app_version;
  } else {
    clear_has_app_version();
    app_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RespLogin

// required .Netty4.CommRlt rlt = 1;
inline bool RespLogin::has_rlt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespLogin::set_has_rlt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespLogin::clear_has_rlt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespLogin::clear_rlt() {
  if (rlt_ != NULL) rlt_->::Netty4::CommRlt::Clear();
  clear_has_rlt();
}
inline const ::Netty4::CommRlt& RespLogin::rlt() const {
  return rlt_ != NULL ? *rlt_ : *default_instance_->rlt_;
}
inline ::Netty4::CommRlt* RespLogin::mutable_rlt() {
  set_has_rlt();
  if (rlt_ == NULL) rlt_ = new ::Netty4::CommRlt;
  return rlt_;
}
inline ::Netty4::CommRlt* RespLogin::release_rlt() {
  clear_has_rlt();
  ::Netty4::CommRlt* temp = rlt_;
  rlt_ = NULL;
  return temp;
}
inline void RespLogin::set_allocated_rlt(::Netty4::CommRlt* rlt) {
  delete rlt_;
  rlt_ = rlt;
  if (rlt) {
    set_has_rlt();
  } else {
    clear_has_rlt();
  }
}

// -------------------------------------------------------------------

// PPTNode

// required int32 id = 1;
inline bool PPTNode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PPTNode::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PPTNode::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PPTNode::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 PPTNode::id() const {
  return id_;
}
inline void PPTNode::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string image = 2;
inline bool PPTNode::has_image() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PPTNode::set_has_image() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PPTNode::clear_has_image() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PPTNode::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& PPTNode::image() const {
  return *image_;
}
inline void PPTNode::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void PPTNode::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void PPTNode::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PPTNode::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* PPTNode::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PPTNode::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 order = 3;
inline bool PPTNode::has_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PPTNode::set_has_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PPTNode::clear_has_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PPTNode::clear_order() {
  order_ = 0;
  clear_has_order();
}
inline ::google::protobuf::int32 PPTNode::order() const {
  return order_;
}
inline void PPTNode::set_order(::google::protobuf::int32 value) {
  set_has_order();
  order_ = value;
}

// -------------------------------------------------------------------

// ReqPPTList

// required int32 vspid = 1;
inline bool ReqPPTList::has_vspid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqPPTList::set_has_vspid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqPPTList::clear_has_vspid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqPPTList::clear_vspid() {
  vspid_ = 0;
  clear_has_vspid();
}
inline ::google::protobuf::int32 ReqPPTList::vspid() const {
  return vspid_;
}
inline void ReqPPTList::set_vspid(::google::protobuf::int32 value) {
  set_has_vspid();
  vspid_ = value;
}

// required int32 userid = 2;
inline bool ReqPPTList::has_userid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqPPTList::set_has_userid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqPPTList::clear_has_userid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqPPTList::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 ReqPPTList::userid() const {
  return userid_;
}
inline void ReqPPTList::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// -------------------------------------------------------------------

// RespPPTList

// required .Netty4.CommRlt rlt = 1;
inline bool RespPPTList::has_rlt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespPPTList::set_has_rlt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespPPTList::clear_has_rlt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespPPTList::clear_rlt() {
  if (rlt_ != NULL) rlt_->::Netty4::CommRlt::Clear();
  clear_has_rlt();
}
inline const ::Netty4::CommRlt& RespPPTList::rlt() const {
  return rlt_ != NULL ? *rlt_ : *default_instance_->rlt_;
}
inline ::Netty4::CommRlt* RespPPTList::mutable_rlt() {
  set_has_rlt();
  if (rlt_ == NULL) rlt_ = new ::Netty4::CommRlt;
  return rlt_;
}
inline ::Netty4::CommRlt* RespPPTList::release_rlt() {
  clear_has_rlt();
  ::Netty4::CommRlt* temp = rlt_;
  rlt_ = NULL;
  return temp;
}
inline void RespPPTList::set_allocated_rlt(::Netty4::CommRlt* rlt) {
  delete rlt_;
  rlt_ = rlt;
  if (rlt) {
    set_has_rlt();
  } else {
    clear_has_rlt();
  }
}

// required int32 tag = 2;
inline bool RespPPTList::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RespPPTList::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RespPPTList::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RespPPTList::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 RespPPTList::tag() const {
  return tag_;
}
inline void RespPPTList::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// optional string desc = 3;
inline bool RespPPTList::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RespPPTList::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RespPPTList::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RespPPTList::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& RespPPTList::desc() const {
  return *desc_;
}
inline void RespPPTList::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void RespPPTList::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void RespPPTList::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RespPPTList::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* RespPPTList::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RespPPTList::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Netty4.PPTNode node = 4;
inline int RespPPTList::node_size() const {
  return node_.size();
}
inline void RespPPTList::clear_node() {
  node_.Clear();
}
inline const ::Netty4::PPTNode& RespPPTList::node(int index) const {
  return node_.Get(index);
}
inline ::Netty4::PPTNode* RespPPTList::mutable_node(int index) {
  return node_.Mutable(index);
}
inline ::Netty4::PPTNode* RespPPTList::add_node() {
  return node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Netty4::PPTNode >&
RespPPTList::node() const {
  return node_;
}
inline ::google::protobuf::RepeatedPtrField< ::Netty4::PPTNode >*
RespPPTList::mutable_node() {
  return &node_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Netty4

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Netty4::CommMessageType>() {
  return ::Netty4::CommMessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PROTOCOL_2eproto__INCLUDED
